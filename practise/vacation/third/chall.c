#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <string.h>

#define TBL_SIZE 12
#define BUFF_SIZE 0x20
#define tbl_idx(id) id%(TBL_SIZE-1)

#define pexit(x) do {                           \
  perror(x);                                    \
  exit(EXIT_FAILURE);                           \
  }while(0);

struct session{
  int cookie;
  char * ptr;
  void (* handle)(char *);
  struct session * next;
};

struct header{
  struct session * * table_ptr;
  struct session * current_session;
};

struct header header;
struct session * table[TBL_SIZE];

size_t Read(char* ptr, size_t size) {
  int ret = read(0,ptr,size-1);
  if (ret<0)
    exit(0);
  ptr[ret-1]='\0';
  return ret-1;
}

size_t Write(char * ptr,size_t size){
  return write(1,ptr,size);
}

void display(char *ptr){
    printf("Content : ");
    Write(ptr,BUFF_SIZE);
    printf("\n");
}

int64_t getInt() {
  char buf[30];
  Read(buf,30);
  
  return atol(buf);
}

void * Malloc(size_t size){
  void * ptr = malloc(size);
  if(!ptr)pexit("malloc");
  memset(ptr,0x0,size);
  return ptr;
}

void initialize(){
  srand(time(0));
  setvbuf(stdout, NULL, _IONBF, 0);
  setvbuf(stderr, NULL, _IONBF, 0);
  setvbuf(stdin, NULL, _IONBF, 0);
  header.table_ptr=table;
  return;
}

int64_t getId(){
  int64_t id;
  printf("Enter the Id : ");
  id = getInt();
  if(id<0) exit(EXIT_FAILURE);
  return id;
}

void restore(char * ptr){
  printf("TODO : restores the current session\n");
}

void Insert(int id,char * ptr){
  struct session * tmp,* m = Malloc(sizeof(struct session));
  
  int idx;
  m->ptr  = ptr;
  m->cookie = rand();
  m->handle = restore;
  m->next = NULL;

  idx = tbl_idx(id);
  if(!table[idx])
    table[idx] = m;
  else {
    tmp = table[idx];
    for(;tmp->next != NULL;tmp = tmp->next);
    tmp->next = m;
  }
  printf("Cookie : %x\n",m->cookie);
}

void Store() {
  int id;
  char * ptr;
  id = getId();
  ptr = Malloc(BUFF_SIZE);
  printf("Content : ");
  Read(ptr,BUFF_SIZE);

  Insert(id,ptr);
}

int getCookie() {
  printf("Enter Cookie : ");
  return getInt();
}


void Load(){
  int id,idx,cookie;
  struct session * m;

  id = getId();
  cookie=getCookie();
  idx = tbl_idx(id);
  m = table[idx];
  if(m){
    if(m->cookie== cookie){
      header.current_session = table[idx];
      table[idx]=m->next;
      display(m->ptr);
      return;
    }
    if(m->next){
      for(;m->next->cookie!= cookie&& m->next->next != NULL;m = m->next);
      if(m->next->cookie== cookie) {
        header.current_session = m->next;
        m->next=m->next->next;
        display(m->ptr);
        return;
      }}
  }
  printf("Session not Found!\n");
  return;
}


void Remove(){
  struct session * tmp;
  int idx , id ,cookie;

  id=getId();
  cookie = getCookie();
  if(header.current_session && header.current_session->cookie== cookie){
    tmp = header.current_session;
    header.current_session=NULL;
    free(tmp->ptr);
    free(tmp);
    return;
  }
  idx = tbl_idx(id);
  tmp = table[idx];
  if(tmp) {
    if(tmp->cookie== cookie){
      table[idx]=tmp->next;
      free(tmp->ptr);
      free(tmp);
      return;
    }
    if(tmp->next){
      for(;tmp->next->cookie!= cookie&& tmp->next->next != NULL;tmp = tmp->next);
      if(tmp->next->cookie== cookie) {
        free(tmp->next->ptr);
        free(tmp->next);
        tmp->next=tmp->next->next;
        return;
      }
    }}
  else
    printf("Invalid Id\n");
  exit(EXIT_FAILURE);
}

void Restore(struct session * m){
  if(m)
    m->handle(m->ptr);
  else
    printf("No session to restore\n");
}

void menu(){
  puts("1 : New Session");
  puts("2 : Load Session");
  puts("3 : Remove Session");
  puts("4 : Restore Session");
  printf(">> ");
  return;
}
int main()
{
  initialize();
  do{
    menu();
    switch(getInt()){
        case 1: Store();break;
        case 2: Load();break;
        case 3: Remove();break;
        case 4: Restore(header.current_session);break;
        default : break;
    }
  }while(1);

  return 0;
}
